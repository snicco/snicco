<?php

declare(strict_types=1);

namespace Snicco\Component\HttpRouting\Routing\UrlMatcher;

use Psr\Container\ContainerExceptionInterface;
use Psr\Container\NotFoundExceptionInterface;
use Snicco\Component\HttpRouting\Http\Psr7\Request;
use Snicco\Component\HttpRouting\Routing\Condition\RouteConditionFactory;
use Snicco\Component\HttpRouting\Routing\Exception\MethodNotAllowed;
use Snicco\Component\HttpRouting\Routing\Route\Route;
use Snicco\Component\HttpRouting\Routing\Route\Routes;
use Snicco\Component\StrArr\Str;
use Webmozart\Assert\Assert;

use function array_merge;
use function count;
use function is_array;
use function preg_match;

/*
 * This class is modified version of nikic/fast-routes RegexBaseAbstract RouteDispatcher.
 * FastRoute is licensed with the MIT License.
 *
 */

/*
* Copyright (c) 2013 by Nikita Popov.
*
* Some rights reserved.

* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are
* met:
*
* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following
  disclaimer in the documentation and/or other materials provided
  with the distribution.

* The names of the contributors may not be used to endorse or
  promote products derived from this software without specific
  prior written permission.

* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

/**
 * We can't use the default dispatcher provided in fast-route because it would
 * not allow us to match conditions. We would only be able to match conditions
 * after the route pattern has already matched. This class is based on {@see
 * \FastRoute\DataGenerator\GroupCountBased}
 * https://github.com/nikic/FastRoute/blob/v1.3.0/src/Dispatcher/RegexBasedAbstract.php
 * This class is tightly coupled to data generated by.
 *
 * {@see \FastRoute\DataGenerator\GroupCountBased}
 * https://github.com/nikic/FastRoute/blob/v1.3.0/src/DataGenerator/GroupCountBased.php.
 *
 * @interal
 * @psalm-internal Snicco\Component\HttpRouting
 */
final class FastRouteDispatcher implements UrlMatcher
{
    private Routes $routes;

    private RouteConditionFactory $condition_factory;

    /**
     * A multidimensional array where each HTTP Verbs contains an array of [path
     * => route_name] pairs.
     *
     * @var array<string,array<string,string>>
     */
    private array $static_route_map = [];

    /**
     * A multidimensional array where each HTTP Verbs contains multiple arrays
     * of route definitions. pairs.
     *
     * @var array<string, array< array{
     * regex: string,
     * routeMap: array<int,array{0: string, 1: array<string,string>}>
     * }>>
     */
    private array $dynamic_route_map = [];

    public function __construct(Routes $routes, array $data, RouteConditionFactory $condition_factory)
    {
        $this->routes = $routes;
        [$static_map, $dynamic_route_map] = $data;
        Assert::isArray($static_map);
        Assert::isArray($dynamic_route_map);
        /** @psalm-suppress MixedPropertyTypeCoercion */
        $this->static_route_map = $static_map;
        /** @psalm-suppress MixedPropertyTypeCoercion */
        $this->dynamic_route_map = $dynamic_route_map;
        $this->condition_factory = $condition_factory;
    }

    /**
     * @throws MethodNotAllowed
     */
    public function dispatch(Request $request): RoutingResult
    {
        $path = $request->decodedPath();
        $request_method = $request->getMethod();

        if (isset($this->static_route_map[$request_method][$path])) {
            $result = $this->dispatchStaticRoute($request_method, $path, $request);

            if ($result->isMatch()) {
                return $result;
            }
        }

        if (isset($this->dynamic_route_map[$request_method])) {
            $result = $this->dispatchVariableRoute($this->dynamic_route_map[$request_method], $path, $request);

            if ($result->isMatch()) {
                return $result;
            }
        }

        // For HEAD requests, attempt fallback to GET
        if ('HEAD' === $request_method) {
            if (isset($this->static_route_map['GET'][$path])) {
                $result = $this->dispatchStaticRoute('GET', $path, $request);

                if ($result->isMatch()) {
                    return $result;
                }
            }

            if (isset($this->dynamic_route_map['GET'])) {
                $result = $this->dispatchVariableRoute($this->dynamic_route_map['GET'], $path, $request);

                if ($result->isMatch()) {
                    return $result;
                }
            }
        }

        $allowed_methods = [];

        foreach ($this->static_route_map as $method => $uri_map) {
            if ($request_method === $method) {
                continue;
            }

            if (! isset($uri_map[$path])) {
                continue;
            }

            $res = $this->dispatchStaticRoute($method, $path, $request);

            if ($res->isMatch()) {
                $allowed_methods[] = $method;
            }
        }

        if ([] !== $allowed_methods) {
            throw MethodNotAllowed::currentMethod($request_method, $allowed_methods, $path);
        }

        foreach ($this->dynamic_route_map as $method => $route_data) {
            if ($request_method === $method) {
                continue;
            }

            $result = $this->dispatchVariableRoute($route_data, $path, $request);
            if ($result->isMatch()) {
                $allowed_methods[] = $method;
            }
        }

        if ([] !== $allowed_methods) {
            throw MethodNotAllowed::currentMethod($request_method, $allowed_methods, $path);
        }

        return RoutingResult::noMatch();
    }

    private function dispatchStaticRoute(string $method, string $path, Request $request): RoutingResult
    {
        $route_name = $this->static_route_map[$method][$path];
        $route = $this->routes->getByName($route_name);
        $res = $this->checkRouteConditions($route, $request);

        if (is_array($res)) {
            return RoutingResult::match($this->routes->getByName($route_name), $res);
        }

        return RoutingResult::noMatch();
    }

    /**
     * @throws ContainerExceptionInterface
     * @throws NotFoundExceptionInterface
     *
     * @return array<string,string>|false
     */
    private function checkRouteConditions(Route $route, Request $request)
    {
        // We allowed FastRoute to match optional segments with and without trailing slash because
        // fast route natively only supports optional segments with no trailing slash.
        // Because of this we need to check explicitly here.
        $has_optional_segments = [] !== $route->getOptionalSegmentNames();
        $request_has_trailing = Str::endsWith($request->path(), '/');
        $route_needs_trailing = Str::endsWith($route->getPattern(), '/');

        if ($route_needs_trailing && $has_optional_segments && ! $request_has_trailing) {
            return false;
        }

        $args = [];
        foreach ($route->getConditions() as $blueprint) {
            $instance = ($this->condition_factory)($blueprint);

            if (! $instance->isSatisfied($request)) {
                return false;
            }

            $args = array_merge($args, $instance->getArguments($request));
        }

        return $args;
    }

    /**
     * @param array<array{
     *      regex: string,
     *      routeMap: array<int,array{0: string, 1: array<string,string>}>
     * }> $variable_route_data
     *
     * @throws ContainerExceptionInterface
     * @throws NotFoundExceptionInterface
     */
    private function dispatchVariableRoute(array $variable_route_data, string $path, Request $request): RoutingResult
    {
        foreach ($variable_route_data as $data) {
            Assert::keyExists($data, 'regex');
            Assert::keyExists($data, 'routeMap');
            if (! preg_match($data['regex'], $path, $matches)) {
                continue;
            }

            [$route_name, $segment_names] = $data['routeMap'][count($matches)];

            $vars = [];
            $i = 0;
            foreach ($segment_names as $segment_name) {
                $vars[$segment_name] = $matches[++$i];
            }

            $route = $this->routes->getByName($route_name);

            $res = $this->checkRouteConditions($route, $request);

            if (is_array($res)) {
                return RoutingResult::match($route, array_merge($vars, $res));
            }
        }

        return RoutingResult::noMatch();
    }
}
