# A secure, modular and framework-agnostic PHP library to sign and verify urls.

[![codecov](https://img.shields.io/badge/Coverage-100%25-success
)](https://app.codecov.io/gh/sniccowp/sniccowp)
[![Psalm Type-Coverage](https://shepherd.dev/github/sniccowp/sniccowp/coverage.svg?)](https://shepherd.dev/github/sniccowp/sniccowp)
[![Psalm level](https://shepherd.dev/github/sniccowp/sniccowp/level.svg?)](https://psalm.dev/)
[![PhpMetrics - Static Analysis](https://img.shields.io/badge/PhpMetrics-Static_Analysis-2ea44f)](https://sniccowp.github.io/sniccowp/phpmetrics/SignedUrl/index.html)

## Table of contents

1. [Motivation](#motivation)
2. [Dependencies](#dependencies)
3. [Installation](#how-to-install)
4. [Usage](#how-to-use)
    1. [Creating a secret](#creating-a-secret)
    2. [Signing an url](#creating-a-signed-url)
    3. [Validating a signed url](#validating-a-signed-url)
        1. [PSR-15 middleware](#PSR-15)
        2. [Other PHP applications](#validating-a-signed-url)
5. [Supported storage types](#supported-storage-types)
    1. [Session](#session)
    2. [Memory](#memory)
    3. [PSR-16-cache](#psr-16-cache)
    4. [WordPress object cache](#wordpress-object-cache)
    5. [Implementing your own](#implementing-your-own-storage)

## Motivation

While developing the [SniccoWP framework](https://github.com/sniccowp/sniccowp) we couldn't find any good
**standalone** PHP-libraries for signing urls. We needed this functionality in a couple of places, so we decided to roll
our own implementation.

Features:

- Uses strong, random secrets, generated by
  a [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically-secure_pseudorandom_number_generator) and secure hash
  functions.
- Validates the signature, the expiration and an enforced usage-limit on a per url basis.
- PSR-7/15 compatible. No hidden dependencies on PHP super globals.
- Protection against [cache-timing-attacks](https://blog.ircmaxell.com/2014/11/its-all-about-time.html)
- Permanently invalidates a signed-url after the max usage. (Rotating your secret invalidates all signed-urls)
- Defensively programmed, making incorrect usage very hard.
- Support for multiple storage backends.
- A properly tested and straightforward API.

## Dependencies

- PHP ^7.4|^8.0
- [paragonie/constant_time_encoding](https://github.com/paragonie/constant_time_encoding)
- [webmozart/assert](https://github.com/webmozarts/assert)

## How to Install

```sh
composer require sniccowp/signed-url
```

## How to Use

### Creating a secret

Run the following command from your project root and store the generated secret in a secure location that is outside
your web root.

```shell
vendor/bin/generate-signed-url-secret
```

**This secret should NEVER be stored in version control.**

Load the secret from an environment variable in your application

```php
// require 'vendor/autoload.php';
$secret = \Snicco\Component\SignedUrl\Secret::fromHexEncoded(getenv('SIGNED_URL_SECRET'));
```

### Creating a signed-url

```php
$secret = /* */

$hmac = new Snicco\Component\SignedUrl\HMAC($secret, 'sha256')

// This is a simple interface.
// check the provided storages below in the repo or simple provide your own.
$storage = new \Snicco\Component\SignedUrl\Storage\SessionStorage($_SESSION);

$signer = new \Snicco\Component\SignedUrl\UrlSigner($storage, $hmac);

$lifetime_in_sec = 60;

$usage_limit = 1;

// optional: as a fourth parameter,
$context = $_SERVER['REMOTE_ADDR'].$_SERVER['HTTP_USER_AGENT']

$signed_url = $signer->sign('https://example.com/unsubscribe?user_id=12' , $lifetime_in_sec, $usage_limit, $context);

$mailer = /* */

$href = $signed_url->asString();

// $href will be something like transformers:
// https://example.com/unsubscribe?user_id=12expires=1639783661&signature=Del1cGmLB1wVET6PJieCrQ==|1MTBBGIpEGPVuGaKDjjrHDBusMNoWB15Ng5lKBSSLQY=

$mailer->send('user12@gmail.com', "Click <a href='{{$href}}'> here <a/> to unsubscribe.")
```

### Validating a signed-url

Validation signed urls should be performed in a middleware to avoid boilerplate.
<br> The code samples below describe the **manual** way to validate urls in any PHP app.

#### PSR-15 middleware

If your favorite framework is psr7/psr15 compatible and supports middleware on a per-route basis, you can use our
inbuilt [psr15 middleware](https://github.com/sniccowp/sniccowp/tree/master/src/Snicco/Bridge/signed-url-psr15-bridge)
which makes usage dead simple.

#### All PHP apps

```php
// Clean expired links periodically.
try {
    // 0-100
    $percentage = 2;
   \Snicco\Component\SignedUrl\GarbageCollector::clean($storage, $percentage);
   
} catch (RuntimeException $e) {
    // gc did not work for some reason. Log and continue.
    error_log($e->getMessage());
    
}

$validator = new \Snicco\Component\SignedUrl\SignedUrlValidator($storage, $hmac);

$target = $_SERVER['PATH_INFO'].'?'.$_SERVER['QUERY_STRING'];

try {

    // optional context, has to be the same scheme used at creation.
    $context = $_SERVER['REMOTE_ADDR'].$_SERVER['HTTP_USER_AGENT']
    
    $validator->validate( $target, $context);
    
} catch (\Snicco\Component\SignedUrl\Exception\InvalidSignature $e ) {
        
   error_log("invalid signature.");     
   echo "This link has expired. Please request a new one."
    
} catch (\Snicco\Component\SignedUrl\Exception\SignedUrlExpired $e ) {

   error_log("signed url expired.");    
   echo "This link has expired. Please request a new one."
   
} catch (\Snicco\Component\SignedUrl\Exception\SignedUrlUsageExceeded $e ) {

   error_log("signed url usage exceeded.");  
   echo "This link has expired. Please request a new one."
}

// Everything is valid.
// If the link can be used multiple times the usage is decremented automatically by 1.
echo "You have been unsubscribed."
```

## Supported storage types

Every signed url storage implements `Snicco\SignedUrl\Contracts\SingedUrlStorage`.<br>By default, the following storage
classes are provided:

### Session:

***

Will use an array passed by reference or an object implementing ArrayAccess.

```php
$arr = new MyArrayAccess();
$storage = new \Snicco\Component\SignedUrl\Storage\SessionStorage($arr);

$storage = new \Snicco\Component\SignedUrl\Storage\SessionStorage($_SESSION);
```

### Memory:

***

You can use the InMemoryStorage during unit tests.

```php
$storage = new \Snicco\Component\SignedUrl\Storage\InMemoryStorage()
```

### PSR-16 Cache

---

There is a
dedicated [PSR-16 bridge](https://github.com/sniccowp/sniccowp/tree/master/src/Snicco/Bridge/signed-url-psr16-bridge)
that allows you to use any compatible cache driver.

### WordPress Object Cache

---

You can use
our [psr16 adapter for the WordPress object cache](https://github.com/sniccowp/sniccowp/tree/master/src/Snicco/Component/wp-object-cache-psr16)
in combination with the PSR-16 storage.

### Implementing your own storage:

Implementing your own storage is very easy. Simply implement
the [SignedUrlStorage](https://github.com/sniccowp/sniccowp/blob/master/src/Snicco/Component/signed-url/src/Storage/SignedUrlStorage.php)
interface. There is
a [trait](https://github.com/sniccowp/sniccowp/blob/master/src/Snicco/Component/signed-url/testing/SignedUrlStorageTests.php)
that you can use in your phpunit tests to test your implementation.


